<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ë–∏—Ç–≤–∞ –∑–∞ —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏¬†v9¬†(10√ó10)</title>
  <style>
    /* ========== BASIC LAYOUT ========== */
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      background: #f4f6fa;
      margin: 0;
      padding-bottom: 120px;
    }
    h1 { margin: 10px 0 0; }

    /* ========== HUD PANELS ========== */
    .info {
      display: flex;
      justify-content: space-around;
      background: rgba(0, 0, 0, 0.07);
      padding: 10px;
    }
    .panel {
      background: #fff;
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
      min-width: 120px;
    }

    /* ========== GRID ========== */
    .grid {
      display: grid;
      grid-template-columns: repeat(10, 40px);
      grid-gap: 4px;
      margin: 20px auto;
      width: 436px; /* 10√ó40 + 9√ó4 */
    }
    .cell {
      width: 40px;
      height: 40px;
      border: 1px solid #888;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      background: #ddd;
      transition: transform 0.2s;
      position: relative;
      outline: none;
    }
    .cell:focus { box-shadow: 0 0 0 2px #1976d2; }
    .cell:hover { transform: scale(1.1); background: #ccc; }

    /* Territories */
    .player1-territory { background: rgba(0, 0, 255, 0.2); }
    .player2-territory { background: rgba(255, 0, 0, 0.2); }

    /* Special unit styling */
    .scout-unit { 
      animation: scout-pulse 1s infinite alternate;
      font-size: 1.2em;
      text-shadow: 0 0 5px yellow;
    }

    @keyframes scout-pulse {
      0% { transform: scale(1); }
      100% { transform: scale(1.3); }
    }

    /* Selection & Highlights */
    .selected { outline: 3px solid #ff0; }
    .valid-move { animation: move-pulse 1s infinite; }
    .valid-attack { animation: attack-pulse 1s infinite; }

    @keyframes move-pulse {
      0%   { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7); }
      50%  { box-shadow: 0 0 0 8px rgba(0, 255, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7); }
    }
    @keyframes attack-pulse {
      0%   { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
      50%  { box-shadow: 0 0 0 8px rgba(255, 0, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
    }

    /* ========== BUTTONS & CONTROLS ========== */
    button {
      margin: 5px;
      padding: 8px 12px;
      font-size: 14px;
      border: none;
      border-radius: 4px;
      background: #1976d2;
      color: #fff;
      cursor: pointer;
    }
    button:disabled { background: #999; cursor: not-allowed; }
    .controls { margin: 10px; }

    /* ========== HISTORY ========== */
    .history {
      max-height: 150px;
      overflow-y: auto;
      margin: 10px auto;
      width: 436px;
      text-align: left;
      background: #fff;
      padding: 10px;
      border-radius: 5px;
    }

    /* ========== POP‚ÄëUPS ========== */
    .menu, .hint, .winner, .rules {
      position: fixed;
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
      z-index: 1000;
    }
    .menu, .hint { top: 50%; left: 50%; transform: translate(-50%, -50%); min-width: 300px; }
    .winner { top: 30%; left: 50%; transform: translate(-50%, -30%); }
    .rules { bottom: 20px; right: 20px; text-align: left; min-width: 200px; }
    .rules.hidden { display: none; }
    .error-message { color: #c00; margin: 10px 0; font-weight: bold; }

    /* Scout specific styles */
    @keyframes scout-button-glow {
      0% { box-shadow: 0 0 5px gold; }
      50% { box-shadow: 0 0 15px gold; }
      100% { box-shadow: 0 0 5px gold; }
    }
    
    .scout-button {
      animation: scout-button-glow 2s infinite;
      transform: scale(1.05);
    }
    
    /* God Mode Button Styles */
    @keyframes godmode-pulse {
      0% { box-shadow: 0 0 5px gold; }
      50% { box-shadow: 0 0 15px gold, 0 0 20px rgba(255, 215, 0, 0.5); }
      100% { box-shadow: 0 0 5px gold; }
    }
    
    .god-mode-active {
      background: linear-gradient(45deg, gold, orange) !important;
      color: black !important;
      font-weight: bold !important;
      animation: godmode-pulse 1.5s infinite !important;
      transform: scale(1.05);
    }

    /* Auto Play Button */
    .auto-play-button {
      background: #4CAF50 !important;
      color: white !important;
    }
    
    .auto-play-button:hover {
      background: #45a049 !important;
    }
  </style>
</head>
<body>
  <h1>–ë–∏—Ç–≤–∞ –∑–∞ —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏¬†v9</h1>
  <button id="toggleRules">–ü—Ä–∞–≤–∏–ª–∞</button>
  <div id="rules" class="rules">
    <h3>–ü—Ä–∞–≤–∏–ª–∞</h3>
    <ul>
      <li>–ü–æ–ª–µ: 10√ó10.</li>
      <li>–§–∞–∑–∞ —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏: –∫–∞–∂–¥—ã–π —Ä–∞–∑–º–µ—â–∞–µ—Ç 3 —Ä—ã—Ü–∞—Ä—è –Ω–∞ —Å–≤–æ–∏—Ö —Ñ–ª–∞–Ω–≥–∞—Ö.</li>
      <li>–§–∞–∑–∞ –∏–≥—Ä—ã: –≤—ã–±—Ä–∞—Ç—å —é–Ω–∏—Ç–∞, –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –∏–ª–∏ –∞—Ç–∞–∫–æ–≤–∞—Ç—å.</li>
      <li>–†–µ—Å—É—Ä—Å—ã: –∫–∞–∂–¥—É—é —Ñ–∞–∑—É –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ +1 –∑–∞ –∫–∞–∂–¥—É—é –≤–∞—à—É —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—é.</li>
      <li>–ü–æ–∫—É–ø–∫–∞: —é–Ω–∏—Ç—ã –¥–æ—Å—Ç—É–ø–Ω—ã –ø—Ä–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã—Ö —Ä–µ—Å—É—Ä—Å–∞—Ö –∏ —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω—ã –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–π.</li>
      <li>–ü–æ–±–µ–¥–∞: —É –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –Ω–µ—Ç —é–Ω–∏—Ç–æ–≤ –∏–ª–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–æ –≤—Å—ë –ø–æ–ª–µ (—Å—Ä–∞–≤–Ω–∏–≤–∞—é—Ç—Å—è —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏).</li>
      <li>–°–∫–∞—É—Ç (üî≠): –ß–∏—Ç–µ—Ä—Å–∫–∏–π —é–Ω–∏—Ç –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è. –°—Ç–æ–∏—Ç 1 —Ä–µ—Å—É—Ä—Å, —Ö–æ–¥–∏—Ç –Ω–∞ 10 –∫–ª–µ—Ç–æ–∫ –∏ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –≤—Å—é —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—é –≤ —Ä–∞–¥–∏—É—Å–µ 3 –∫–ª–µ—Ç–æ–∫.</li>
    </ul>
  </div>

  <div id="root"></div>

  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script type="module">
  import { UNITS, UNIT_SYMBOLS, ABILITIES } from './units.js';
  
  (function () {
    const e = React.createElement;

    /* ========== CONSTANTS ========== */
    const SIZE = 10;          // —Ä–∞–∑–º–µ—Ä –ø–æ–ª—è
    const INIT = 3;           // —é–Ω–∏—Ç–æ–≤ –≤ —Å—Ç–∞—Ä—Ç–æ–≤–æ–π —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–µ

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∏–∑ units.js
    const TYPES = UNITS;

    /* –°–æ—Å–µ–¥–Ω–∏–µ –∫–ª–µ—Ç–∫–∏ (4‚Äë—Å–≤—è–∑–Ω–æ—Å—Ç—å) */
    const neigh = (x, y) =>
      [[x - 1, y], [x + 1, y], [x, y - 1], [x, y + 1]].filter(
        ([i, j]) => i >= 0 && i < SIZE && j >= 0 && j < SIZE
      );

    /* ========== REACT COMPONENTS ========== */
    const { useState, useEffect } = React;

    // –ö–ª–µ—Ç–∫–∞ –ø–æ–ª—è
    function Cell({ i, j, terr, unit, selected, validMove, validAttack, onClick }) {
      let className = "cell";
      if (terr === 1) className += " player1-territory";
      if (terr === 2) className += " player2-territory";
      if (selected) className += " selected";
      if (validMove) className += " valid-move";
      if (validAttack) className += " valid-attack";
      
      // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∫–ª–∞—Å—Å –¥–ª—è –°–∫–∞—É—Ç–∞
      const isScout = unit && unit.type === 'SCOUT';
      const unitClassName = isScout ? "scout-unit" : "";
      
      return (
        e('div', {
          className,
          tabIndex: 0,
          'aria-label': `–ö–ª–µ—Ç–∫–∞ ${i},${j}${unit ? `, ${TYPES[unit.type].description}, HP:${unit.hp}` : ''}`,
          onClick: () => onClick(i, j),
          onKeyDown: e => { if (e.key === "Enter" || e.key === " ") onClick(i, j); }
        },
          unit && e('span', { 
            title: `HP:${unit.hp}`, 
            className: unitClassName 
          }, UNIT_SYMBOLS[unit.type])
        )
      );
    }

    // –°–µ—Ç–∫–∞ –ø–æ–ª—è
    function Grid({ units, terr, sel, moves, att, onCellClick }) {
      let cells = [];
      for (let i = 0; i < SIZE; i++) {
        for (let j = 0; j < SIZE; j++) {
          cells.push(
            e(Cell, {
              key: `${i},${j}`,
              i, j,
              terr: terr[i][j],
              unit: units[i][j],
              selected: sel && sel.x === i && sel.y === j,
              validMove: moves.some(m => m[0] === i && m[1] === j),
              validAttack: att.some(a => a[0] === i && a[1] === j),
              onClick: onCellClick
            })
          );
        }
      }
      return e('div', { className: 'grid' }, cells);
    }

    // –ü–∞–Ω–µ–ª—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    function HUD({ pl, res, phase, turn }) {
      return e('div', { className: 'info' },
        e('div', { className: 'panel' }, `Player: ${pl}`),
        e('div', { className: 'panel' }, `‚ú∂ ${res}`),
        e('div', { className: 'panel' }, `Phase: ${phase}`),
        e('div', { className: 'panel' }, `Turn: ${turn}`)
      );
    }

    // –ò—Å—Ç–æ—Ä–∏—è —Ö–æ–¥–æ–≤
    function History({ hist }) {
      return e('div', { className: 'history' },
        e('h4', null, 'History'),
        e('ul', null, hist.map((m, i) => e('li', { key: i }, m)))
      );
    }

    // –ú–µ–Ω—é –ø–æ–∫—É–ø–∫–∏
    function BuyMenu({ terr, pl, res, onBuy, onClose }) {
      const unitButtons = Object.entries(TYPES)
        .sort(([, a], [, b]) => a.unlock - b.unlock)
        .map(([k, v]) =>
          e('button', {
            key: k,
            title: `${v.description}\n–°—Ç–æ–∏–º–æ—Å—Ç—å: ${v.cost}\n–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞: ${v.unlock} —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–π`,
            disabled: (res < v.cost || terr.flat().filter(t => t === pl).length < v.unlock),
            onClick: () => onBuy(k)
          }, `${UNIT_SYMBOLS[k]} ${v.description} (${v.cost})`)
        );
      
      return e('div', { className: 'menu', role: 'dialog', 'aria-modal': 'true' },
        e('h4', null, 'Buy Unit'),
        ...unitButtons,
        e('button', { onClick: onClose }, 'Close')
      );
    }

    // –ì–ª–∞–≤–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    function App() {
      // –°–æ—Å—Ç–æ—è–Ω–∏—è
      const [units, setUnits] = useState(Array(SIZE).fill().map(() => Array(SIZE).fill(null)));
      const [terr, setTerr] = useState(Array(SIZE).fill().map(() => Array(SIZE).fill(null)));
      const [res, setRes] = useState(0);
      const [placed, setPlaced] = useState(0);
      const [phase, setPhase] = useState('placement');
      const [pl, setPl] = useState(1);
      const [sel, setSel] = useState(null);
      const [moves, setMoves] = useState([]);
      const [att, setAtt] = useState([]);
      const [menu, setMenu] = useState(false);
      const [place, setPlace] = useState(null);
      const [hint, setHint] = useState(false);
      const [hist, setHist] = useState([]);
      const [turn, setTurn] = useState(1);
      const [win, setWin] = useState(null);
      const [error, setError] = useState(null);
      const [isGodMode, setIsGodMode] = useState(false);
      const [isAutoPlaying, setIsAutoPlaying] = useState(false);

      // –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Ñ–∞–∑–µ –∏–≥—Ä—ã –ø–æ—Å–ª–µ —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏
      useEffect(() => {
        if (phase === 'placement' && placed === INIT * 2) {
          setPhase('game');
          if (!isGodMode) {
            setHist(h => [...h, '–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è –∏–≥—Ä–∞']);
          }
        }
      }, [phase, placed, isGodMode]);

      // –î–æ—Ö–æ–¥ —Ä–µ—Å—É—Ä—Å–æ–≤ –≤ –Ω–∞—á–∞–ª–µ —Ö–æ–¥–∞
      useEffect(() => {
        if (phase === 'game') {
          const inc = terr.flat().filter(t => t === pl).length;
          setRes(r => r + inc);
          if (!isGodMode) {
            setHist(h => [...h, `+${inc}‚ú∂ –∑–∞ —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏`]);
          }
        }
      }, [turn, isGodMode]);

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–±–µ–¥—ã
      useEffect(() => {
        if (phase === 'game') {
          const flat = units.flat();
          if (!flat.some(u => u && u.pl === 1)) setWin(2);
          else if (!flat.some(u => u && u.pl === 2)) setWin(1);
          else if (flat.every(u => u)) {
            const c1 = terr.flat().filter(t => t === 1).length;
            const c2 = terr.flat().filter(t => t === 2).length;
            setWin(c1 > c2 ? 1 : c2 > c1 ? 2 : 'Draw');
          }
        }
      }, [units]);

      // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è
      useEffect(() => {
        const state = { units, terr, res, placed, phase, pl, sel, moves, att, menu, place, hint, hist, turn, win, isGodMode };
        localStorage.setItem('battleGameState', JSON.stringify(state));
      }, [units, terr, res, placed, phase, pl, sel, moves, att, menu, place, hint, hist, turn, win, isGodMode]);

      // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è
      useEffect(() => {
        const saved = localStorage.getItem('battleGameState');
        if (saved) {
          try {
            const state = JSON.parse(saved);
            setUnits(state.units);
            setTerr(state.terr);
            setRes(state.res);
            setPlaced(state.placed);
            setPhase(state.phase);
            setPl(state.pl);
            setSel(state.sel);
            setMoves(state.moves);
            setAtt(state.att);
            setMenu(state.menu);
            setPlace(state.place);
            setHint(state.hint);
            setHist(state.hist);
            setTurn(state.turn);
            setWin(state.win);
            if (state.isGodMode) setIsGodMode(state.isGodMode);
          } catch {}
        }
      }, []);

      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ö–æ–¥–∞
      function executeMove(fromX, fromY, toX, toY) {
        const u = units.map(r => r.slice());
        const t = terr.map(r => r.slice());
        const c = u[fromX][fromY];
        u[fromX][fromY] = null;
        u[toX][toY] = c;
        
        if (c.type === 'SCOUT') {
          for (let x = Math.max(0, toX - 1); x <= Math.min(SIZE - 1, toX + 1); x++) {
            for (let y = Math.max(0, toY - 1); y <= Math.min(SIZE - 1, toY + 1); y++) {
              t[x][y] = pl;
            }
          }
          if (!isGodMode) {
            setHist(h => [...h, `–°–∫–∞—É—Ç –∑–∞—Ö–≤–∞—Ç–∏–ª —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—é –≤–æ–∫—Ä—É–≥ ${toX},${toY}`]);
          }
        } else {
          t[toX][toY] = pl;
          t[fromX][fromY] = pl;
        }
        
        setUnits(u);
        setTerr(t);
        if (!isGodMode) {
          setHist(h => [...h, `Mv@${toX},${toY}`]);
        }
        return true;
      }

      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∞—Ç–∞–∫–∏
      function executeAttack(fromX, fromY, toX, toY) {
        if (!units[fromX][fromY] || units[fromX][fromY].pl !== pl) return false;
        if (!units[toX][toY] || units[toX][toY].pl === pl) return false;
        
        const u = units.map(r => r.slice());
        const attacker = u[fromX][fromY];
        const defender = u[toX][toY];
        const dmg = Math.max(1, TYPES[attacker.type].dam - TYPES[defender.type].arm);
        defender.hp -= dmg;
        
        let msg = `${attacker.type}->${defender.type}-${dmg}`;
        if (defender.hp <= 0) {
          u[toX][toY] = attacker;
          u[fromX][fromY] = null;
          const t2 = terr.map(r => r.slice());
          t2[toX][toY] = pl;
          setUnits(u);
          setTerr(t2);
          if (!isGodMode) {
            setHist(h => [...h, msg + ',dead']);
          }
        } else {
          u[toX][toY] = defender;
          setUnits(u);
          if (!isGodMode) {
            setHist(h => [...h, msg + ` HP${defender.hp}`]);
          }
        }
        return true;
      }

      // –°–±—Ä–æ—Å –∏–≥—Ä—ã
      function reset() {
        setIsGodMode(false);
        setIsAutoPlaying(false);
        localStorage.removeItem('battleGameState');
        window.location.reload();
      }

      // –ö–æ–Ω–µ—Ü —Ö–æ–¥–∞
      function end() {
        setSel(null);
        setMoves([]);
        setAtt([]);
        setTurn(t => t + 1);
        setPl(p => p === 1 ? 2 : 1);
      }

      // –£—Å–æ–≤–µ—Ä—à–µ–Ω—Å—Ç–≤–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º –ë–æ–≥–∞
      function handleGodMode() {
        if (!isGodMode) {
          setIsGodMode(true);
          
          // –ï—Å–ª–∏ –≤ —Ñ–∞–∑–µ —Ä–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∏ –∏ –Ω–µ –≤—Å–µ —é–Ω–∏—Ç—ã —Ä–∞–∑–º–µ—â–µ–Ω—ã, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞–∑–º–µ—â–∞–µ–º –∏—Ö
          if (phase === 'placement') {
            autoPlaceInitialUnits();
          } else if (phase === 'game') {
            // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –∏–≥—Ä—É
            setTimeout(godModeAction, 300);
          }
        } else {
          setIsGodMode(false);
        }
      }
      
      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –Ω–∞—á–∞–ª—å–Ω—ã—Ö —é–Ω–∏—Ç–æ–≤
      function autoPlaceInitialUnits() {
        if (placed >= INIT * 2) return;
        
        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∑–æ–Ω—É –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
        const zone = pl === 1 ? [0, 1, 2] : [SIZE - 3, SIZE - 2, SIZE - 1];
        const initialPlacements = [];
        
        // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –º–µ—Å—Ç–∞ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
        for (let i of zone) {
          for (let j = 0; j < SIZE; j++) {
            if (!units[i][j]) {
              initialPlacements.push([i, j]);
            }
          }
        }
        
        // –ï—Å–ª–∏ –µ—Å—Ç—å –º–µ—Å—Ç–∞ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∏ –Ω—É–∂–Ω–æ –µ—â–µ —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å —é–Ω–∏—Ç–æ–≤
        if (initialPlacements.length > 0 && placed < INIT * 2) {
          // –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
          initialPlacements.sort(([i1, j1], [i2, j2]) => {
            const center = SIZE / 2 - 0.5;
            const dist1 = Math.abs(j1 - center);
            const dist2 = Math.abs(j2 - center);
            return dist1 - dist2;
          });
          
          // –†–∞–∑–º–µ—â–∞–µ–º —é–Ω–∏—Ç–∞
          const [i, j] = initialPlacements[0];
          setTimeout(() => {
            handle(i, j);
            
            // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ, –µ—Å–ª–∏ –µ—â–µ –Ω–µ –≤—Å–µ —é–Ω–∏—Ç—ã —Ä–∞–∑–º–µ—â–µ–Ω—ã
            if (placed + 1 < INIT * 2) {
              setTimeout(autoPlaceInitialUnits, 100);
            }
          }, 100);
        }
      }
      
      // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–µ–π—Å—Ç–≤–∏–π –≤ —Ä–µ–∂–∏–º–µ –ë–æ–≥–∞
      function godModeAction() {
        if (!isGodMode || win) return;
        
        if (phase === 'placement') {
          autoPlaceInitialUnits();
          return;
        }
        
        if (phase === 'placing') {
          // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Ä–∞–∑–º–µ—â–∞–µ–º –∫—É–ø–ª–µ–Ω–Ω–æ–≥–æ —é–Ω–∏—Ç–∞
          const availableSpots = [];
          for (let i = 0; i < SIZE; i++) {
            for (let j = 0; j < SIZE; j++) {
              if (!units[i][j] && terr[i][j] === pl) {
                // –û—Ü–µ–Ω–∏–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é - –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º –≥—Ä–∞–Ω–∏—Ü—ã —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏
                let borderScore = 0;
                for (const [nx, ny] of neigh(i, j)) {
                  if (!terr[nx][ny] || terr[nx][ny] !== pl) {
                    borderScore += 1;
                  }
                }
                availableSpots.push([i, j, borderScore]);
              }
            }
          }
          
          if (availableSpots.length > 0) {
            availableSpots.sort((a, b) => b[2] - a[2]);
            const [bestI, bestJ] = availableSpots[0];
            setTimeout(() => {
              handle(bestI, bestJ);
            }, 100);
          } else {
            setTimeout(cancelPlacing, 100);
          }
          return;
        }
        
        setTimeout(() => {
          let actionPerformed = false;
          
          // –®–∞–≥ 1: –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —é–Ω–∏—Ç—ã —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
          const playerUnits = [];
          for (let i = 0; i < SIZE; i++) {
            for (let j = 0; j < SIZE; j++) {
              if (units[i][j] && units[i][j].pl === pl) {
                playerUnits.push([i, j, units[i][j]]);
              }
            }
          }
          
          // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º —é–Ω–∏—Ç—ã –¥–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π
          playerUnits.sort(() => Math.random() - 0.5);
          
          // –®–∞–≥ 2: –ü—Ä–æ–±—É–µ–º –¥–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å –∫–∞–∂–¥—ã–º —é–Ω–∏—Ç–æ–º
          for (const [unitX, unitY, unit] of playerUnits) {
            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∞—Ç–∞–∫–∏
            const attackOptions = [];
            for (const [nx, ny] of neigh(unitX, unitY)) {
              if (units[nx][ny] && units[nx][ny].pl !== pl) {
                const damage = Math.max(1, TYPES[unit.type].dam - TYPES[units[nx][ny].type].arm);
                const canKill = damage >= units[nx][ny].hp;
                attackOptions.push({
                  x: nx,
                  y: ny,
                  damage: damage,
                  canKill: canKill,
                  priority: canKill ? 2 : 1
                });
              }
            }
            
            // –ï—Å–ª–∏ –µ—Å—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∞—Ç–∞–∫–∏ - –∞—Ç–∞–∫—É–µ–º
            if (attackOptions.length > 0) {
              attackOptions.sort((a, b) => b.priority - a.priority || b.damage - a.damage);
              const bestAttack = attackOptions[0];
              if (executeAttack(unitX, unitY, bestAttack.x, bestAttack.y)) {
                actionPerformed = true;
                break;
              }
            }
            
            // –ï—Å–ª–∏ –Ω–µ –∞—Ç–∞–∫–æ–≤–∞–ª–∏ - –ø—Ä–æ–±—É–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è
            if (!actionPerformed) {
              const moveOptions = [];
              const moveRange = TYPES[unit.type].mv;
              
              // BFS –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–π
              const visited = Array(SIZE).fill().map(() => Array(SIZE).fill(false));
              const queue = [[unitX, unitY, 0]];
              visited[unitX][unitY] = true;
              
              while (queue.length > 0) {
                const [x, y, dist] = queue.shift();
                
                if (dist > 0 && !units[x][y]) {
                  let score = 0;
                  
                  // –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –∑–∞—Ö–≤–∞—Ç–∞ –Ω–æ–≤–æ–π —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏
                  if (terr[x][y] !== pl) {
                    score += 20; // –£–≤–µ–ª–∏—á–∏–ª–∏ —Å 10 –¥–æ 20
                  }
                  
                  // –®—Ç—Ä–∞—Ñ –∑–∞ –¥–≤–∏–∂–µ–Ω–∏–µ –ø–æ —Å–≤–æ–µ–π —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏
                  if (terr[x][y] === pl) {
                    score -= 10; // –£–≤–µ–ª–∏—á–∏–ª–∏ —à—Ç—Ä–∞—Ñ —Å 5 –¥–æ 10
                  }
                  
                  // –ë–æ–Ω—É—Å –∑–∞ –¥–≤–∏–∂–µ–Ω–∏–µ –∫ —Ü–µ–Ω—Ç—Ä—É
                  const centerDist = Math.abs(x - SIZE/2) + Math.abs(y - SIZE/2);
                  score += (SIZE - centerDist);
                  
                  // –ë–æ–Ω—É—Å –∑–∞ –±–ª–∏–∑–æ—Å—Ç—å –∫ –≤—Ä–∞–∂–µ—Å–∫–∏–º —é–Ω–∏—Ç–∞–º
                  for (const [nx, ny] of neigh(x, y)) {
                    if (units[nx][ny] && units[nx][ny].pl !== pl) {
                      score += 5;
                    }
                  }
                  
                  // –ë–æ–Ω—É—Å –∑–∞ –¥–≤–∏–∂–µ–Ω–∏–µ –∫ –Ω–µ–∑–∞—Ö–≤–∞—á–µ–Ω–Ω–æ–π —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏
                  let expansionBonus = 0;
                  for (const [nx, ny] of neigh(x, y)) {
                    if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE) {
                      if (!terr[nx][ny]) {
                        expansionBonus += 3;
                      }
                    }
                  }
                  score += expansionBonus;
                  
                  moveOptions.push({
                    x: x,
                    y: y,
                    dist: dist,
                    score: score
                  });
                }
                
                if (dist < moveRange) {
                  for (const [nx, ny] of neigh(x, y)) {
                    if (!visited[nx][ny] && !units[nx][ny]) {
                      visited[nx][ny] = true;
                      queue.push([nx, ny, dist + 1]);
                    }
                  }
                }
              }
              
              // –ï—Å–ª–∏ –µ—Å—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–≤–∏–∂–µ–Ω–∏—è
              if (moveOptions.length > 0) {
                moveOptions.sort((a, b) => b.score - a.score);
                
                // –ü—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º —Ö–æ–¥—ã –Ω–∞ –Ω–æ–≤—É—é —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—é
                const newTerritoryMoves = moveOptions.filter(opt => terr[opt.x][opt.y] !== pl);
                
                if (newTerritoryMoves.length > 0) {
                  const bestMove = newTerritoryMoves[0];
                  if (executeMove(unitX, unitY, bestMove.x, bestMove.y)) {
                    actionPerformed = true;
                    break;
                  }
                } else if (moveOptions.length > 0) {
                  const bestMove = moveOptions[0];
                  if (executeMove(unitX, unitY, bestMove.x, bestMove.y)) {
                    actionPerformed = true;
                    break;
                  }
                }
              }
            }
          }
          
          // –®–∞–≥ 3: –ï—Å–ª–∏ –Ω–µ —Å–¥–µ–ª–∞–ª–∏ —Ö–æ–¥ - –ø—Ä–æ–±—É–µ–º –∫—É–ø–∏—Ç—å —é–Ω–∏—Ç–∞
          if (!actionPerformed) {
            const territoryCount = terr.flat().filter(t => t === pl).length;
            const canPlace = terr.some((row, i) => row.some((t, j) => t === pl && !units[i][j]));
            
            if (canPlace) {
              const availableTypes = Object.entries(TYPES)
                .filter(([k, v]) => v.cost <= res && territoryCount >= v.unlock)
                .sort((a, b) => {
                  if (a[0] === 'SCOUT') return -1;
                  if (b[0] === 'SCOUT') return 1;
                  return b[1].cost - a[1].cost;
                });
              
              if (availableTypes.length > 0) {
                const [unitType] = availableTypes[0];
                buy(unitType);
                actionPerformed = true;
              }
            }
          }
          
          // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ —Å–¥–µ–ª–∞–ª–∏ - –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ–º —Ö–æ–¥
          if (!actionPerformed) {
            setTimeout(end, 100);
          } else {
            setTimeout(godModeAction, 300);
          }
        }, 300);
      }
      
      // –ò—Å–ø–æ–ª—å–∑—É–µ–º —ç—Ñ—Ñ–µ–∫—Ç –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ –∏–≥—Ä—ã –¥–ª—è godMode
      useEffect(() => {
        if (isGodMode && !win && !menu) {
          if (phase === 'placement') {
            autoPlaceInitialUnits();
          } else if (phase === 'game' && !sel && !isAutoPlaying) {
            setTimeout(godModeAction, 300);
          } else if (phase === 'placing') {
            setTimeout(godModeAction, 300);
          }
        }
      }, [isGodMode, phase, pl, turn]);

      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–≤–µ—Ä—à–∞–µ—Ç –æ–¥–∏–Ω —Ö–æ–¥ –∑–∞ –∏–≥—Ä–æ–∫–∞
      function autoPlayOneTurn() {
        if (phase !== 'game' || win || isAutoPlaying) return;
        
        setIsAutoPlaying(true);
        
        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—É –∂–µ –ª–æ–≥–∏–∫—É, —á—Ç–æ –∏ –≤ godModeAction, –Ω–æ —Ç–æ–ª—å–∫–æ –¥–ª—è –æ–¥–Ω–æ–≥–æ —Ö–æ–¥–∞
        setTimeout(() => {
          let actionPerformed = false;
          
          // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —é–Ω–∏—Ç—ã —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
          const playerUnits = [];
          for (let i = 0; i < SIZE; i++) {
            for (let j = 0; j < SIZE; j++) {
              if (units[i][j] && units[i][j].pl === pl) {
                playerUnits.push([i, j, units[i][j]]);
              }
            }
          }
          
          // 1. –ü—Ä–æ–±—É–µ–º –∞—Ç–∞–∫–æ–≤–∞—Ç—å
          for (const [unitX, unitY, unit] of playerUnits) {
            const attackOptions = [];
            
            for (const [nx, ny] of neigh(unitX, unitY)) {
              if (units[nx][ny] && units[nx][ny].pl !== pl) {
                const damage = Math.max(1, TYPES[unit.type].dam - TYPES[units[nx][ny].type].arm);
                const canKill = damage >= units[nx][ny].hp;
                
                attackOptions.push({
                  x: nx,
                  y: ny,
                  damage: damage,
                  canKill: canKill,
                  priority: canKill ? 2 : 1
                });
              }
            }
            
            if (attackOptions.length > 0) {
              attackOptions.sort((a, b) => b.priority - a.priority || b.damage - a.damage);
              const bestAttack = attackOptions[0];
              
              if (executeAttack(unitX, unitY, bestAttack.x, bestAttack.y)) {
                actionPerformed = true;
                setTimeout(() => {
                  setIsAutoPlaying(false);
                  end();
                }, 300);
                return;
              }
            }
          }
          
          // 2. –ï—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º –∞—Ç–∞–∫–æ–≤–∞—Ç—å, –ø—Ä–æ–±—É–µ–º –¥–≤–∏–≥–∞—Ç—å—Å—è
          if (!actionPerformed) {
            // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º —é–Ω–∏—Ç—ã –¥–ª—è —Ä–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏—è
            playerUnits.sort(() => Math.random() - 0.5);
            
            for (const [unitX, unitY, unit] of playerUnits) {
              const moveOptions = [];
              const moveRange = TYPES[unit.type].mv;
              
              // BFS –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤–æ–∑–º–æ–∂–Ω—ã—Ö –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–π
              const visited = Array(SIZE).fill().map(() => Array(SIZE).fill(false));
              const queue = [[unitX, unitY, 0]];
              visited[unitX][unitY] = true;
              
              while (queue.length > 0) {
                const [x, y, dist] = queue.shift();
                
                if (dist > 0 && !units[x][y]) {
                  let score = 0;
                  
                  // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –Ω–µ–∑–∞—Ö–≤–∞—á–µ–Ω–Ω—ã–º —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è–º
                  if (terr[x][y] !== pl) {
                    score += 10;
                  } else {
                    // –®—Ç—Ä–∞—Ñ –∑–∞ –¥–≤–∏–∂–µ–Ω–∏–µ –ø–æ —Å–≤–æ–µ–π —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏
                    score -= 5;
                  }
                  
                  // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç —Ü–µ–Ω—Ç—Ä—É
                  const centerDist = Math.abs(x - SIZE/2) + Math.abs(y - SIZE/2);
                  score += (SIZE - centerDist) / 2;
                  
                  moveOptions.push({
                    x: x,
                    y: y,
                    dist: dist,
                    score: score
                  });
                }
                
                if (dist < moveRange) {
                  for (const [nx, ny] of neigh(x, y)) {
                    if (!visited[nx][ny] && !units[nx][ny]) {
                      visited[nx][ny] = true;
                      queue.push([nx, ny, dist + 1]);
                    }
                  }
                }
              }
              
              if (moveOptions.length > 0) {
                moveOptions.sort((a, b) => b.score - a.score);
                
                // –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –Ω–µ-—Å–≤–æ–∏–º —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏—è–º
                const nonBacktrackOptions = moveOptions.filter(opt => terr[opt.x][opt.y] !== pl);
                
                const bestMove = nonBacktrackOptions.length > 0 ? nonBacktrackOptions[0] : moveOptions[0];
                
                if (executeMove(unitX, unitY, bestMove.x, bestMove.y)) {
                  actionPerformed = true;
                  setTimeout(() => {
                    setIsAutoPlaying(false);
                    end();
                  }, 300);
                  return;
                }
              }
            }
          }
          
          // 3. –ï—Å–ª–∏ –Ω–µ –º–æ–∂–µ–º —Ö–æ–¥–∏—Ç—å –∏–ª–∏ –∞—Ç–∞–∫–æ–≤–∞—Ç—å, –ø—Ä–æ–±—É–µ–º –∫—É–ø–∏—Ç—å —é–Ω–∏—Ç–∞
          if (!actionPerformed) {
            const territoryCount = terr.flat().filter(t => t === pl).length;
            const canPlace = terr.some((row, i) => row.some((t, j) => t === pl && !units[i][j]));
            
            if (canPlace) {
              const availableTypes = Object.entries(TYPES)
                .filter(([k, v]) => v.cost <= res && territoryCount >= v.unlock)
                .sort((a, b) => {
                  if (a[0] === 'SCOUT') return -1;
                  if (b[0] === 'SCOUT') return 1;
                  return b[1].cost - a[1].cost;
                });
              
              if (availableTypes.length > 0) {
                const [unitType, unitData] = availableTypes[0];
                buy(unitType);
                actionPerformed = true;
                setTimeout(() => {
                  setIsAutoPlaying(false);
                }, 300);
                return;
              }
            }
          }
          
          // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ —Å–¥–µ–ª–∞–ª–∏, –∑–∞–∫–∞–Ω—á–∏–≤–∞–µ–º —Ö–æ–¥
          if (!actionPerformed) {
            setTimeout(() => {
              setIsAutoPlaying(false);
              end();
            }, 100);
          }
        }, 300);
      }

      // –ü–æ–∫—É–ø–∫–∞ —é–Ω–∏—Ç–∞
      function buy(type) {
        // –û—Å–æ–±–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –°–∫–∞—É—Ç–∞ - –≤—Å–µ–≥–¥–∞ –¥–æ—Å—Ç—É–ø–µ–Ω
        if (type === 'SCOUT') {
          const canPlace = terr.some((row, i) => row.some((t, j) => t === pl && !units[i][j]));
          if (!canPlace) {
            setError('–ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è!');
            return;
          }
          setMenu(false); setPhase('placing'); setPlace(type); 
          // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –≤ god mode
          if (!isGodMode) {
            setHint(true);
          }
          // –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç–æ–∏–º–æ—Å—Ç—å –¥–ª—è –°–∫–∞—É—Ç–∞ - 1 —Ä–µ—Å—É—Ä—Å, –¥–∞–∂–µ –µ—Å–ª–∏ —É –∏–≥—Ä–æ–∫–∞ –º–µ–Ω—å—à–µ
          setRes(r => Math.max(0, r - 1));
          return;
        }
        
        // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –¥—Ä—É–≥–∏—Ö —é–Ω–∏—Ç–æ–≤
        const unlocked = terr.flat().filter(t => t === pl).length >= TYPES[type].unlock;
        if (res < TYPES[type].cost || !unlocked) return;
        const canPlace = terr.some((row, i) => row.some((t, j) => t === pl && !units[i][j]));
        if (!canPlace) {
          setError('–ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö –∫–ª–µ—Ç–æ–∫ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è!');
          return;
        }
        setMenu(false); setPhase('placing'); setPlace(type); 
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –Ω–µ –≤ god mode
        if (!isGodMode) {
          setHint(true);
        }
        setRes(r => r - TYPES[type].cost);
      }
      
      // –û—Ç–º–µ–Ω–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
      function cancelPlacing() {
        setPhase('game'); setPlace(null); setHint(false);
      }
      
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ –∫–ª–µ—Ç–∫–µ
      function handle(i, j) {
        if (win) return;
        setError(null);
        // –†–∞—Å—Å—Ç–∞–Ω–æ–≤–∫–∞
        if (phase === 'placement') {
          const zone = pl === 1 ? i < INIT : i >= SIZE - INIT;
          if (!units[i][j] && zone) {
            const u = units.map(r => r.slice());
            const t = terr.map(r => r.slice());
            u[i][j] = { type: 'KNIGHT', pl, hp: TYPES.KNIGHT.hp };
            t[i][j] = pl;
            setUnits(u); setTerr(t); setPlaced(p => p + 1); 
            if (!isGodMode) {
              setHist(h => [...h, `K@${i},${j}`]);
            }
            setPl(3 - pl);
          }
          return;
        }
        // –†–∞–∑–º–µ—â–µ–Ω–∏–µ –∫—É–ø–ª–µ–Ω–Ω–æ–≥–æ —é–Ω–∏—Ç–∞
        if (phase === 'placing') {
          if (!units[i][j] && terr[i][j] === pl) {
            const u = units.map(r => r.slice());
            u[i][j] = { type: place, pl, hp: TYPES[place].hp };
            setUnits(u);
            if (!isGodMode) {
              setHist(h => [...h, `${place}@${i},${j}`]);
            }
            setPhase('game'); setHint(false); setPlace(null);
            end();
          }
          return;
        }
        // –û—Å–Ω–æ–≤–Ω–∞—è –∏–≥—Ä–∞
        if (phase === 'game') {
          if (sel) {
            if (moves.some(m => m[0] === i && m[1] === j)) {
              // –•–æ–¥
              executeMove(sel.x, sel.y, i, j);
              setSel(null); setMoves([]); setAtt([]);
              end();
              return;
            }
            if (att.some(a => a[0] === i && a[1] === j)) {
              // –ê—Ç–∞–∫–∞
              executeAttack(sel.x, sel.y, i, j);
              setSel(null); setMoves([]); setAtt([]);
              end();
              return;
            }
            setSel(null); setMoves([]); setAtt([]);
            return;
          }
          // –í—ã–±–æ—Ä —Å–≤–æ–µ–≥–æ —é–Ω–∏—Ç–∞
          const cell = units[i][j];
          if (cell && cell.pl === pl) {
            // BFS –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ —Ö–æ–¥–æ–≤
            const vis = Array(SIZE).fill().map(() => Array(SIZE).fill(false));
            const q = [[i, j, 0]];
            vis[i][j] = true;
            const mv = [], at = [];
            while (q.length) {
              const [x, y, d] = q.shift();
              if (d > 0 && !units[x][y]) mv.push([x, y]);
              if (d === TYPES[cell.type].mv) continue;
              neigh(x, y).forEach(([nx, ny]) => {
                if (vis[nx][ny]) return;
                vis[nx][ny] = true;
                if (units[nx][ny] && units[nx][ny].pl !== pl) at.push([nx, ny]);
                else q.push([nx, ny, d + 1]);
              });
            }
            setSel({ x: i, y: j }); setMoves(mv); setAtt(at);
          }
        }
      }

      // –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å: Escape –¥–ª—è –æ—Ç–º–µ–Ω—ã —Ä–∞–∑–º–µ—â–µ–Ω–∏—è
      useEffect(() => {
        function esc(e) {
          if (e.key === 'Escape' && hint) cancelPlacing();
        }
        window.addEventListener('keydown', esc);
        return () => window.removeEventListener('keydown', esc);
      }, [hint]);

      // –†–µ–Ω–¥–µ—Ä
      return e('div', null,
        e(HUD, { pl, res, phase, turn }),
        e(Grid, { units, terr, sel, moves, att, onCellClick: handle }),
        e('div', { className: 'controls' },
          phase === 'game' && e('button', { onClick: () => setMenu(true) }, 'Buy'),
          phase === 'game' && e('button', { onClick: end }, 'End'),
          phase === 'game' && e('button', { 
            className: 'auto-play-button',
            disabled: isAutoPlaying || isGodMode,
            onClick: autoPlayOneTurn 
          }, 'Auto Play'),
          e('button', {
            className: isGodMode ? 'god-mode-active' : '',
            onClick: handleGodMode
          }, isGodMode ? 'GOD MODE: ON' : 'GOD MODE: OFF'),
          e('button', { onClick: reset }, 'Reset'),
          e('button', { onClick: () => { localStorage.removeItem('battleGameState'); window.location.reload(); } }, 'Clear Save')
        ),
        menu && e(BuyMenu, { terr, pl, res, onBuy: buy, onClose: () => setMenu(false) }),
        hint && e('div', { className: 'hint', role: 'alertdialog' },
          e('p', null, place === 'SCOUT' 
            ? '–©—ë–ª–∫–Ω–∏—Ç–µ –ø–æ —Å–≤–æ–µ–π —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏, —á—Ç–æ–±—ã —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å –°–∫–∞—É—Ç–∞. –≠—Ç–æ—Ç —é–Ω–∏—Ç –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –±–æ–ª—å—à–∏–µ —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏!' 
            : '–©—ë–ª–∫–Ω–∏—Ç–µ –ø–æ —Å–≤–æ–µ–π —Ç–µ—Ä—Ä–∏—Ç–æ—Ä–∏–∏, —á—Ç–æ–±—ã —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å —é–Ω–∏—Ç–∞, –∏–ª–∏ –æ—Ç–º–µ–Ω–∏—Ç–µ.'),
          e('button', { onClick: cancelPlacing }, '–û—Ç–º–µ–Ω–∞')
        ),
        error && e('div', { className: 'error-message' }, error),
        !isGodMode && e(History, { hist }),
        win && e('div', { className: 'winner', role: 'alertdialog' },
          e('h2', null, typeof win === 'number' ? `Player ${win} wins` : 'Draw'),
          e('button', { onClick: reset }, 'Replay')
        )
      );
    }

    // –†–µ–Ω–¥–µ—Ä–∏–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    ReactDOM.render(e(App), document.getElementById('root'));

    // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª
    document.getElementById('toggleRules').onclick = () =>
      document.getElementById('rules').classList.toggle('hidden');
  })();
  </script>
</body>
</html>

